\hypertarget{class_up_down_1_1_sim_u_d_runtime__t}{}\doxysection{Up\+Down\+::Sim\+UDRuntime\+\_\+t Class Reference}
\label{class_up_down_1_1_sim_u_d_runtime__t}\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}


Wrapper class that allows simulation of runtime calls.  




{\ttfamily \#include $<$simupdown.\+h$>$}

Inheritance diagram for Up\+Down\+::Sim\+UDRuntime\+\_\+t\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_up_down_1_1_sim_u_d_runtime__t}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a1af458c531ea3297c7991facbed758fa}{Sim\+UDRuntime\+\_\+t}} ()
\begin{DoxyCompactList}\small\item\em Construct a new \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t}{Sim\+UDRuntime\+\_\+t}} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_adc38b9beb3dcfc1abd60e11869894a97}{Sim\+UDRuntime\+\_\+t}} (\mbox{\hyperlink{struct_up_down_1_1ud__machine__t}{ud\+\_\+machine\+\_\+t}} machine\+Config)
\begin{DoxyCompactList}\small\item\em Construct a new \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t}{Sim\+UDRuntime\+\_\+t}} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_ac200dff089c69a7f5e1f8a71a4e1601c}{Sim\+UDRuntime\+\_\+t}} (std\+::string program\+File, std\+::string program\+Name, std\+::string simulation\+Dir, Emulator\+Log\+Level print\+Lvl=Emulator\+Log\+Level\+::\+NONE)
\begin{DoxyCompactList}\small\item\em Construct a new \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t}{Sim\+UDRuntime\+\_\+t}} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a3173647c4905f9eefd115f610a9e25bf}{Sim\+UDRuntime\+\_\+t}} (\mbox{\hyperlink{struct_up_down_1_1ud__machine__t}{ud\+\_\+machine\+\_\+t}} machine\+Config, std\+::string program\+File, std\+::string program\+Name, std\+::string simulation\+Dir, Emulator\+Log\+Level print\+Lvl=Emulator\+Log\+Level\+::\+NONE)
\begin{DoxyCompactList}\small\item\em Construct a new \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t}{Sim\+UDRuntime\+\_\+t}} object. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_af3aead899ca394be4048678a1769da4d}{send\+\_\+event}} (\mbox{\hyperlink{class_up_down_1_1event__t}{event\+\_\+t}} ev)
\begin{DoxyCompactList}\small\item\em Wrapper function for send\+\_\+event. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a4d07ad90b3cd6de2522c7e37ecdaf133}{start\+\_\+exec}} (uint8\+\_\+t ud\+\_\+id, uint8\+\_\+t lane\+\_\+num)
\begin{DoxyCompactList}\small\item\em Wrapper function for start\+\_\+exec. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a811c0050b3d1ce0e696bddb853017972}{t2ud\+\_\+memcpy}} (void $\ast$data, uint64\+\_\+t size, uint8\+\_\+t ud\+\_\+id, uint8\+\_\+t lane\+\_\+num, uint32\+\_\+t offset)
\begin{DoxyCompactList}\small\item\em Wrapper function for t2ud\+\_\+memcpy. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a42d83d235215dc1897eca7a5ee09fc7d}{ud2t\+\_\+memcpy}} (void $\ast$data, uint64\+\_\+t size, uint8\+\_\+t ud\+\_\+id, uint8\+\_\+t lane\+\_\+num, uint32\+\_\+t offset)
\begin{DoxyCompactList}\small\item\em Wrapper function for ud2t\+\_\+memcpy. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a112bba7e502827b810ab98efbf114298}{test\+\_\+addr}} (uint8\+\_\+t ud\+\_\+id, uint8\+\_\+t lane\+\_\+num, uint32\+\_\+t offset, word\+\_\+t expected=1)
\begin{DoxyCompactList}\small\item\em Wrapper function for test\+\_\+addr. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a32ebe16466d123ae02b3f0a56f159e1d}{test\+\_\+wait\+\_\+addr}} (uint8\+\_\+t ud\+\_\+id, uint8\+\_\+t lane\+\_\+num, uint32\+\_\+t offset, word\+\_\+t expected=1)
\begin{DoxyCompactList}\small\item\em Wrapper function for test\+\_\+wait\+\_\+addr. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays}} ()
\begin{DoxyCompactList}\small\item\em Allocate memory for the simulation of the updown. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a76423ee519101241d96a212a307d9d8e}{init\+Python\+Interface}} (Emulator\+Log\+Level print\+Level)
\begin{DoxyCompactList}\small\item\em Initialize interface with python emulator. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_afbfd8cf5e76e6bfe73ada7d6b2fc87eb}\label{class_up_down_1_1_sim_u_d_runtime__t_afbfd8cf5e76e6bfe73ada7d6b2fc87eb}} 
const std\+::string {\bfseries Log\+File\+Name} = \char`\"{}Perf.\+log\char`\"{}
\item 
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_ac5695332065439e720acec84ebcd8932}\label{class_up_down_1_1_sim_u_d_runtime__t_ac5695332065439e720acec84ebcd8932}} 
uint8\+\_\+t $\ast$ {\bfseries Mapped\+Memory}
\item 
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_afd86a86a56eb7d5d8bb3ba6bca6861b6}\label{class_up_down_1_1_sim_u_d_runtime__t_afd86a86a56eb7d5d8bb3ba6bca6861b6}} 
uint8\+\_\+t $\ast$ {\bfseries Scratchpad\+Memory}
\item 
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a98801989caf662cc2561a5b8f398d7af}\label{class_up_down_1_1_sim_u_d_runtime__t_a98801989caf662cc2561a5b8f398d7af}} 
uint8\+\_\+t $\ast$ {\bfseries Control\+Memory}
\item 
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a8cadc421c07eaaade803f27e11b34c6d}\label{class_up_down_1_1_sim_u_d_runtime__t_a8cadc421c07eaaade803f27e11b34c6d}} 
std\+::string {\bfseries program\+File}
\item 
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a5f69771a4ec701e523c20e413650dd4c}\label{class_up_down_1_1_sim_u_d_runtime__t_a5f69771a4ec701e523c20e413650dd4c}} 
std\+::string {\bfseries program\+Name}
\item 
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a178731c895b9958bb67ccb961c9be0ec}\label{class_up_down_1_1_sim_u_d_runtime__t_a178731c895b9958bb67ccb961c9be0ec}} 
std\+::string {\bfseries simulation\+Dir}
\item 
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_ab7f9ede7a8a64f6697503e06fa7620f0}\label{class_up_down_1_1_sim_u_d_runtime__t_ab7f9ede7a8a64f6697503e06fa7620f0}} 
\mbox{\hyperlink{class_upstream___py_intf}{Upstream\+\_\+\+Py\+Intf}} $\ast$ {\bfseries upstream\+\_\+pyintf}
\item 
bool \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a2089ec0c8e5fa757176519f297924360}{python\+\_\+enabled}}
\item 
uint32\+\_\+t $\ast$$\ast$ \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_aba904005137a5c78d50491dbe7cc06aa}{sendmap}}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
Wrapper class that allows simulation of runtime calls. 

This class inherits from \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t}{UDRuntime\+\_\+t}}, and it overwrites the methods such that they can be simulated using a memory region.

This class does not use polymorphism. It just oversubscribes the methods, wrapping the original implementation of the runtime

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000006}{Todo}}]This does not emulate multiple UPDs\end{DoxyRefDesc}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a1af458c531ea3297c7991facbed758fa}\label{class_up_down_1_1_sim_u_d_runtime__t_a1af458c531ea3297c7991facbed758fa}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!SimUDRuntime\_t@{SimUDRuntime\_t}}
\index{SimUDRuntime\_t@{SimUDRuntime\_t}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{SimUDRuntime\_t()}{SimUDRuntime\_t()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::\+Sim\+UDRuntime\+\_\+t (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t}{Sim\+UDRuntime\+\_\+t}} object. 

This constructor calls \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays()}} to set the simulated memory regions. Python will be disabled. Only simulating memory interactions. 

References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a53609a9bdbc8caae702ea49684c0ea64}{Up\+Down\+::\+UDRuntime\+\_\+t\+::calc\+\_\+addrmap()}}, and \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_adc38b9beb3dcfc1abd60e11869894a97}\label{class_up_down_1_1_sim_u_d_runtime__t_adc38b9beb3dcfc1abd60e11869894a97}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!SimUDRuntime\_t@{SimUDRuntime\_t}}
\index{SimUDRuntime\_t@{SimUDRuntime\_t}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{SimUDRuntime\_t()}{SimUDRuntime\_t()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::\+Sim\+UDRuntime\+\_\+t (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_up_down_1_1ud__machine__t}{ud\+\_\+machine\+\_\+t}}}]{machine\+Config }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t}{Sim\+UDRuntime\+\_\+t}} object. 

This constructor calls \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays()}} to set the simulated memory regions. The pointers of ud\+\_\+machine\+\_\+t.\+Mapped\+Mem\+Base, ud\+\_\+machine\+\_\+t.\+UDbase ud\+\_\+machine\+\_\+t.\+SPMem\+Base and ud\+\_\+machine\+\_\+t.\+Control\+Base will be ignored and overwritten in order to simulate the runtime.


\begin{DoxyParams}{Parameters}
{\em machine\+Config} & Machine configuration \\
\hline
\end{DoxyParams}


References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a53609a9bdbc8caae702ea49684c0ea64}{Up\+Down\+::\+UDRuntime\+\_\+t\+::calc\+\_\+addrmap()}}, and \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_ac200dff089c69a7f5e1f8a71a4e1601c}\label{class_up_down_1_1_sim_u_d_runtime__t_ac200dff089c69a7f5e1f8a71a4e1601c}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!SimUDRuntime\_t@{SimUDRuntime\_t}}
\index{SimUDRuntime\_t@{SimUDRuntime\_t}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{SimUDRuntime\_t()}{SimUDRuntime\_t()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::\+Sim\+UDRuntime\+\_\+t (\begin{DoxyParamCaption}\item[{std\+::string}]{program\+File,  }\item[{std\+::string}]{program\+Name,  }\item[{std\+::string}]{simulation\+Dir,  }\item[{Emulator\+Log\+Level}]{print\+Lvl = {\ttfamily EmulatorLogLevel\+:\+:NONE} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t}{Sim\+UDRuntime\+\_\+t}} object. 

This constructor calls \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays()}} to set the simulated memory regions. The pointers of ud\+\_\+machine\+\_\+t.\+Mapped\+Mem\+Base, ud\+\_\+machine\+\_\+t.\+UDbase ud\+\_\+machine\+\_\+t.\+SPMem\+Base and ud\+\_\+machine\+\_\+t.\+Control\+Base will be ignored and overwritten.


\begin{DoxyParams}{Parameters}
{\em machine\+Config} & Machine configuration \\
\hline
\end{DoxyParams}


References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a53609a9bdbc8caae702ea49684c0ea64}{Up\+Down\+::\+UDRuntime\+\_\+t\+::calc\+\_\+addrmap()}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays()}}, and \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a76423ee519101241d96a212a307d9d8e}{init\+Python\+Interface()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a3173647c4905f9eefd115f610a9e25bf}\label{class_up_down_1_1_sim_u_d_runtime__t_a3173647c4905f9eefd115f610a9e25bf}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!SimUDRuntime\_t@{SimUDRuntime\_t}}
\index{SimUDRuntime\_t@{SimUDRuntime\_t}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{SimUDRuntime\_t()}{SimUDRuntime\_t()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::\+Sim\+UDRuntime\+\_\+t (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_up_down_1_1ud__machine__t}{ud\+\_\+machine\+\_\+t}}}]{machine\+Config,  }\item[{std\+::string}]{program\+File,  }\item[{std\+::string}]{program\+Name,  }\item[{std\+::string}]{simulation\+Dir,  }\item[{Emulator\+Log\+Level}]{print\+Lvl = {\ttfamily EmulatorLogLevel\+:\+:NONE} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t}{Sim\+UDRuntime\+\_\+t}} object. 

This constructor calls \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays()}} to set the simulated memory regions. The pointers of ud\+\_\+machine\+\_\+t.\+Mapped\+Mem\+Base, ud\+\_\+machine\+\_\+t.\+UDbase ud\+\_\+machine\+\_\+t.\+SPMem\+Base and ud\+\_\+machine\+\_\+t.\+Control\+Base will be ignored and overwritten.


\begin{DoxyParams}{Parameters}
{\em machine\+Config} & Machine configuration \\
\hline
\end{DoxyParams}


References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a53609a9bdbc8caae702ea49684c0ea64}{Up\+Down\+::\+UDRuntime\+\_\+t\+::calc\+\_\+addrmap()}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}{init\+Memory\+Arrays()}}, and \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a76423ee519101241d96a212a307d9d8e}{init\+Python\+Interface()}}.



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}\label{class_up_down_1_1_sim_u_d_runtime__t_a7113c0fad105b40a81231139332c0061}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!initMemoryArrays@{initMemoryArrays}}
\index{initMemoryArrays@{initMemoryArrays}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{initMemoryArrays()}{initMemoryArrays()}}
{\footnotesize\ttfamily void Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::init\+Memory\+Arrays (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Allocate memory for the simulation of the updown. 

This function allocates the Mapped\+Memory, the Scratchpad memory and the Control Memory, used for the simulation. Then it changes the Machine\+Config object to use these pointers instead of the default ones for these three memory regions.

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000007}{Todo}}]We are allocating the whole address space. We could behave more like a driver and translate it to the actual available memory. This means. It should not allocate the reserved space for expansion. \end{DoxyRefDesc}


References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_ac550f02506c21c5e48b6648c2e8c3dd6}{Up\+Down\+::\+UDRuntime\+\_\+t\+::\+Machine\+Config}}, and \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a327a02b17f491af168ab57569240af8f}{Up\+Down\+::\+UDRuntime\+\_\+t\+::reset\+\_\+memory\+\_\+manager()}}.



Referenced by \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a1af458c531ea3297c7991facbed758fa}{Sim\+UDRuntime\+\_\+t()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a76423ee519101241d96a212a307d9d8e}\label{class_up_down_1_1_sim_u_d_runtime__t_a76423ee519101241d96a212a307d9d8e}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!initPythonInterface@{initPythonInterface}}
\index{initPythonInterface@{initPythonInterface}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{initPythonInterface()}{initPythonInterface()}}
{\footnotesize\ttfamily void Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::init\+Python\+Interface (\begin{DoxyParamCaption}\item[{Emulator\+Log\+Level}]{print\+Level }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Initialize interface with python emulator. 

This function handles initialization of the interface with python EFA emulator. The emulator is in charge of Up\+Down behavior.


\begin{DoxyParams}{Parameters}
{\em print\+Level} & Printing level for the python emulator\\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000008}{Todo}}]when increasing the number of lanes to multiple Up\+Downs, this function must be re-\/implemented \end{DoxyRefDesc}


References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_ac550f02506c21c5e48b6648c2e8c3dd6}{Up\+Down\+::\+UDRuntime\+\_\+t\+::\+Machine\+Config}}, and \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_aba904005137a5c78d50491dbe7cc06aa}{sendmap}}.



Referenced by \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_ac200dff089c69a7f5e1f8a71a4e1601c}{Sim\+UDRuntime\+\_\+t()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_af3aead899ca394be4048678a1769da4d}\label{class_up_down_1_1_sim_u_d_runtime__t_af3aead899ca394be4048678a1769da4d}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!send\_event@{send\_event}}
\index{send\_event@{send\_event}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{send\_event()}{send\_event()}}
{\footnotesize\ttfamily void Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::send\+\_\+event (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_up_down_1_1event__t}{event\+\_\+t}}}]{ev }\end{DoxyParamCaption})}



Wrapper function for send\+\_\+event. 

Calls the emulator and calls the \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_af58fb869d8558462617fa84bf83bb595}{UDRuntime\+\_\+t\+::send\+\_\+event()}} function 

References \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a2089ec0c8e5fa757176519f297924360}{python\+\_\+enabled}}, and \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_af58fb869d8558462617fa84bf83bb595}{Up\+Down\+::\+UDRuntime\+\_\+t\+::send\+\_\+event()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a4d07ad90b3cd6de2522c7e37ecdaf133}\label{class_up_down_1_1_sim_u_d_runtime__t_a4d07ad90b3cd6de2522c7e37ecdaf133}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!start\_exec@{start\_exec}}
\index{start\_exec@{start\_exec}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{start\_exec()}{start\_exec()}}
{\footnotesize\ttfamily void Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::start\+\_\+exec (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{ud\+\_\+id,  }\item[{uint8\+\_\+t}]{lane\+\_\+num }\end{DoxyParamCaption})}



Wrapper function for start\+\_\+exec. 

Calls the emulator and calls the \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_af61e9f01022957944d9c74daf365c0a4}{UDRuntime\+\_\+t\+::start\+\_\+exec()}} function 

References \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a2089ec0c8e5fa757176519f297924360}{python\+\_\+enabled}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_aba904005137a5c78d50491dbe7cc06aa}{sendmap}}, \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_af61e9f01022957944d9c74daf365c0a4}{Up\+Down\+::\+UDRuntime\+\_\+t\+::start\+\_\+exec()}}, and \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a4d07ad90b3cd6de2522c7e37ecdaf133}{start\+\_\+exec()}}.



Referenced by \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a4d07ad90b3cd6de2522c7e37ecdaf133}{start\+\_\+exec()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a811c0050b3d1ce0e696bddb853017972}\label{class_up_down_1_1_sim_u_d_runtime__t_a811c0050b3d1ce0e696bddb853017972}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!t2ud\_memcpy@{t2ud\_memcpy}}
\index{t2ud\_memcpy@{t2ud\_memcpy}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{t2ud\_memcpy()}{t2ud\_memcpy()}}
{\footnotesize\ttfamily void Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::t2ud\+\_\+memcpy (\begin{DoxyParamCaption}\item[{void $\ast$}]{data,  }\item[{uint64\+\_\+t}]{size,  }\item[{uint8\+\_\+t}]{ud\+\_\+id,  }\item[{uint8\+\_\+t}]{lane\+\_\+num,  }\item[{uint32\+\_\+t}]{offset }\end{DoxyParamCaption})}



Wrapper function for t2ud\+\_\+memcpy. 

Calls the emulator and calls the \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_ae7831fce61c9c34db9043c63f0286ebf}{UDRuntime\+\_\+t\+::t2ud\+\_\+memcpy()}} function

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000009}{Todo}}]The physical memory is contiguous, therefore the calculation of this offset is different to the address space in the virtual memory. Is there a way to express this? The runtime is doing some heavy lifting here that is translating things to physical memory \end{DoxyRefDesc}


References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_aa3d126b94a4803a73a7bcbdb18707cb2}{Up\+Down\+::\+UDRuntime\+\_\+t\+::get\+\_\+lane\+\_\+physical\+\_\+memory()}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a2089ec0c8e5fa757176519f297924360}{python\+\_\+enabled}}, and \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_ae7831fce61c9c34db9043c63f0286ebf}{Up\+Down\+::\+UDRuntime\+\_\+t\+::t2ud\+\_\+memcpy()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a112bba7e502827b810ab98efbf114298}\label{class_up_down_1_1_sim_u_d_runtime__t_a112bba7e502827b810ab98efbf114298}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!test\_addr@{test\_addr}}
\index{test\_addr@{test\_addr}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{test\_addr()}{test\_addr()}}
{\footnotesize\ttfamily bool Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::test\+\_\+addr (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{ud\+\_\+id,  }\item[{uint8\+\_\+t}]{lane\+\_\+num,  }\item[{uint32\+\_\+t}]{offset,  }\item[{word\+\_\+t}]{expected = {\ttfamily 1} }\end{DoxyParamCaption})}



Wrapper function for test\+\_\+addr. 

Calls the emulator and calls the \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_ab96599b352e42e823c692ecc4d3ee689}{UDRuntime\+\_\+t\+::test\+\_\+addr()}} function

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000011}{Todo}}]The physical memory is contiguous, therefore the calculation of this offset is different to the address space in the virtual memory. Is there a way to express this? The runtime is doing some heavy lifting here that is translating things to physical memory \end{DoxyRefDesc}


References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a84ed7807df12382d06ee8a09b172898f}{Up\+Down\+::\+UDRuntime\+\_\+t\+::\+Base\+Addrs}}, \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a33fce78b89238e7f2b21fd9e08bf4a2a}{Up\+Down\+::\+UDRuntime\+\_\+t\+::get\+\_\+lane\+\_\+aligned\+\_\+offset()}}, \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_aa3d126b94a4803a73a7bcbdb18707cb2}{Up\+Down\+::\+UDRuntime\+\_\+t\+::get\+\_\+lane\+\_\+physical\+\_\+memory()}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a2089ec0c8e5fa757176519f297924360}{python\+\_\+enabled}}, and \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_ab96599b352e42e823c692ecc4d3ee689}{Up\+Down\+::\+UDRuntime\+\_\+t\+::test\+\_\+addr()}}.



Referenced by \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a32ebe16466d123ae02b3f0a56f159e1d}{test\+\_\+wait\+\_\+addr()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a32ebe16466d123ae02b3f0a56f159e1d}\label{class_up_down_1_1_sim_u_d_runtime__t_a32ebe16466d123ae02b3f0a56f159e1d}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!test\_wait\_addr@{test\_wait\_addr}}
\index{test\_wait\_addr@{test\_wait\_addr}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{test\_wait\_addr()}{test\_wait\_addr()}}
{\footnotesize\ttfamily void Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::test\+\_\+wait\+\_\+addr (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{ud\+\_\+id,  }\item[{uint8\+\_\+t}]{lane\+\_\+num,  }\item[{uint32\+\_\+t}]{offset,  }\item[{word\+\_\+t}]{expected = {\ttfamily 1} }\end{DoxyParamCaption})}



Wrapper function for test\+\_\+wait\+\_\+addr. 

Calls the emulator and calls the \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a7e41c8dae74b2b76e74c8a3d20324d15}{UDRuntime\+\_\+t\+::test\+\_\+wait\+\_\+addr()}} function

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000012}{Todo}}]The physical memory is contiguous, therefore the calculation of this offset is different to the address space in the virtual memory. Is there a way to express this? The runtime is doing some heavy lifting here that is translating things to physical memory \end{DoxyRefDesc}


References \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a112bba7e502827b810ab98efbf114298}{test\+\_\+addr()}}, and \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a7e41c8dae74b2b76e74c8a3d20324d15}{Up\+Down\+::\+UDRuntime\+\_\+t\+::test\+\_\+wait\+\_\+addr()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a42d83d235215dc1897eca7a5ee09fc7d}\label{class_up_down_1_1_sim_u_d_runtime__t_a42d83d235215dc1897eca7a5ee09fc7d}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!ud2t\_memcpy@{ud2t\_memcpy}}
\index{ud2t\_memcpy@{ud2t\_memcpy}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{ud2t\_memcpy()}{ud2t\_memcpy()}}
{\footnotesize\ttfamily void Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::ud2t\+\_\+memcpy (\begin{DoxyParamCaption}\item[{void $\ast$}]{data,  }\item[{uint64\+\_\+t}]{size,  }\item[{uint8\+\_\+t}]{ud\+\_\+id,  }\item[{uint8\+\_\+t}]{lane\+\_\+num,  }\item[{uint32\+\_\+t}]{offset }\end{DoxyParamCaption})}



Wrapper function for ud2t\+\_\+memcpy. 

Calls the emulator and calls the \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a0bde0edbcb8ab5a7a5d5daabb5e75d49}{UDRuntime\+\_\+t\+::ud2t\+\_\+memcpy()}} function

This function copies from the emulator directly into the scratchpad memory and then calls the real runtime function. This allows to keep the logic of the real runtime even though we are simulating the hardware

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{todo__todo000010}{Todo}}]The physical memory is contiguous, therefore the calculation of this offset is different to the address space in the virtual memory. Is there a way to express this? The runtime is doing some heavy lifting here that is translating things to physical memory \end{DoxyRefDesc}


References \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a84ed7807df12382d06ee8a09b172898f}{Up\+Down\+::\+UDRuntime\+\_\+t\+::\+Base\+Addrs}}, \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a33fce78b89238e7f2b21fd9e08bf4a2a}{Up\+Down\+::\+UDRuntime\+\_\+t\+::get\+\_\+lane\+\_\+aligned\+\_\+offset()}}, \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_aa3d126b94a4803a73a7bcbdb18707cb2}{Up\+Down\+::\+UDRuntime\+\_\+t\+::get\+\_\+lane\+\_\+physical\+\_\+memory()}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a2089ec0c8e5fa757176519f297924360}{python\+\_\+enabled}}, and \mbox{\hyperlink{class_up_down_1_1_u_d_runtime__t_a0bde0edbcb8ab5a7a5d5daabb5e75d49}{Up\+Down\+::\+UDRuntime\+\_\+t\+::ud2t\+\_\+memcpy()}}.



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_a2089ec0c8e5fa757176519f297924360}\label{class_up_down_1_1_sim_u_d_runtime__t_a2089ec0c8e5fa757176519f297924360}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!python\_enabled@{python\_enabled}}
\index{python\_enabled@{python\_enabled}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{python\_enabled}{python\_enabled}}
{\footnotesize\ttfamily bool Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::python\+\_\+enabled\hspace{0.3cm}{\ttfamily [private]}}

When python is not enabled, we bypass all the calls to the python interface. This restricts simulation to only memory operations 

Referenced by \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_af3aead899ca394be4048678a1769da4d}{send\+\_\+event()}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a4d07ad90b3cd6de2522c7e37ecdaf133}{start\+\_\+exec()}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a811c0050b3d1ce0e696bddb853017972}{t2ud\+\_\+memcpy()}}, \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a112bba7e502827b810ab98efbf114298}{test\+\_\+addr()}}, and \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a42d83d235215dc1897eca7a5ee09fc7d}{ud2t\+\_\+memcpy()}}.

\mbox{\Hypertarget{class_up_down_1_1_sim_u_d_runtime__t_aba904005137a5c78d50491dbe7cc06aa}\label{class_up_down_1_1_sim_u_d_runtime__t_aba904005137a5c78d50491dbe7cc06aa}} 
\index{UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}!sendmap@{sendmap}}
\index{sendmap@{sendmap}!UpDown::SimUDRuntime\_t@{UpDown::SimUDRuntime\_t}}
\doxysubsubsection{\texorpdfstring{sendmap}{sendmap}}
{\footnotesize\ttfamily uint32\+\_\+t$\ast$$\ast$ Up\+Down\+::\+Sim\+UDRuntime\+\_\+t\+::sendmap\hspace{0.3cm}{\ttfamily [private]}}

Contains a mapped memory to the file system that is used to communicate with the emulator. 

Referenced by \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a76423ee519101241d96a212a307d9d8e}{init\+Python\+Interface()}}, and \mbox{\hyperlink{class_up_down_1_1_sim_u_d_runtime__t_a4d07ad90b3cd6de2522c7e37ecdaf133}{start\+\_\+exec()}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/\+Users/josemonsalvediaz/\+Documents/\+Project38/llvm/updown/simruntime/include/simupdown.\+h\item 
/\+Users/josemonsalvediaz/\+Documents/\+Project38/llvm/updown/simruntime/src/simupdown.\+cpp\end{DoxyCompactItemize}
